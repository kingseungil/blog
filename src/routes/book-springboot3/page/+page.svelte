<!-- auto-generated by QWER -->
<script lang="ts">
  /* eslint-disable @typescript-eslint/ban-ts-comment */
  // @ts-nocheck
  import Post from '$lib/layouts/post.svelte';
  import ImgZoom from '$lib/components/image_zoom.svelte';
  import Video from '$lib/components/video.svelte';
  import CodeCopy from '$lib/components/code_copy.svelte';
  import InfoBox from '$lib/components/info_box.svelte';
</script>

<Post>
  <article slot="post_content">
    <blockquote>
      <p>
        <a
          href="https://ridibooks.com/books/1160000073?_s=search&amp;_q=%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8+%ED%95%B5%EC%8B%AC&amp;_rdt_sid=search&amp;_rdt_idx=0"
          rel="external">
          스프링부트 핵심가이드
        </a>
        을 읽고 정리한 내용입니다.
      </p>
      <p>위 책의 Part 6를 읽고 정리한 내용을 다루고 있습니다.</p>
    </blockquote>
    <h1 id="part-6"><a href="#part-6">Part 6. 데이터 베이스 연동</a></h1>
    <h2 id="orm"><a href="#orm">ORM</a></h2>
    <p>ORM(Object Relational Mapping)은 객체 관계 매핑을 의미합니다.</p>
    <blockquote>
      <p>
        자바와 같은 객체지향 언어에서 의미하는 객체(클래스)와 RDB(Relational Database)의 테이블을 자동으로 매핑하는
        방법입니다. 클래스는 데이터베이스의 테이블과 매핑하기 위해 만들어진 것이 아니기 때문에 RDB 테이블과 어쩔 수 없는
        불일치가 존재합니다.
      </p>
      <p>
        ORM은 이 둘의 <strong>불일치와 제약사항을 해결하는 역할</strong>
        입니다.
        <ImgZoom src="/book-springboot3/page/a.png" alt="/book-springboot3/page/a.png"></ImgZoom>
      </p>
    </blockquote>
    <h3 id="orm"><a href="#orm">ORM 장점</a></h3>
    <ol>
      <li>ORM을 사용하면서 데이터베이트 쿼리를 객체지향적으로 조작할 수 있습니다.</li>
    </ol>
    <ul>
      <li>쿼리문을 작성하는 양이 현저히 줄어 개발 비용이 줄어듭니다.</li>
      <li>객체지향적으로 데이터베이스에 접근할 수 있어 코드의 가독성을 높입니다.</li>
    </ul>
    <ol start="2">
      <li>재사용 및 유지보수가 편리합니다.</li>
    </ol>
    <ul>
      <li>ORM을 통해 매핑된 객체는 모두 독립적으로 작성되어 있어 재사용이 용이합니다.</li>
      <li>객체들은 각 클래스로 나뉘어 있어 유지보수가 수월합니다.</li>
    </ul>
    <ol start="3">
      <li>데이터베이스에 대한 종속성이 줄어듭니다.</li>
    </ol>
    <ul>
      <li>
        ORM을 통해 자동 생성된 SQL문은 객체를 기반으로 데이터베이스 테이블을 관리하기 떄문에 데이터베이스에 종속적이지
        않습니다.
      </li>
      <li>데이터베이스를 교체하는 상황에서도 비교적 적은 리스크를 부담합니다.</li>
    </ul>
    <h3 id="orm"><a href="#orm">ORM 단점</a></h3>
    <ol>
      <li>ORM만으로 온전한 서비스를 구현하기에는 한계가 있습니다.</li>
    </ol>
    <ul>
      <li>복잡한 서비스의 경우 직접 쿼리를 구현하지 않고 코드로 구현하기 어렵습니다.</li>
      <li>복잡한 쿼리를 정확한 설계 없이 ORM만으로 구성하게 되면 속도 저하 등의 성능 문제가 발생할 수 있습니다.</li>
    </ul>
    <ol start="2">
      <li>애플리케이션의 객체 관점과 데이터베이스의 관계 관점의 불일치가 발생합니다.</li>
    </ol>
    <ul>
      <li>
        세분성(Granularity) : ORM의 자동 설계 방법에 따라 데이터베이스에 있는 테이블의 수와 애플리케이션의 엔티티
        클래스의 수가 일치하지 않을 수 있습니다.
      </li>
      <li>
        상속성(Inheritance) : 객체지향 프로그래밍 언어에서는 상속이라는 개념이 존재하지만, 데이터베이스에서는 상속이라는
        개념이 존재하지 않습니다.
      </li>
      <li>식별성(Identity) : 객체는 참조를 통해 식별되지만, 데이터베이스는 주로 기본키를 통해 식별됩니다.</li>
      <li>연관성(Association) : 객체는 참조를 통해 연관되지만, 데이터베이스는 주로 외래키를 통해 연관됩니다.</li>
      <li>탐색(Navigation) : 객체는 참조를 통해 탐색하지만, 데이터베이스는 주로 쿼리를 통해 탐색합니다.</li>
    </ul>
    <h2 id="jpa"><a href="#jpa">JPA</a></h2>
    <p>JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준으로 채택된 인터페이스 모음입니다.</p>
    <InfoBox statusType="tip" statusName="ORM">
      <p>ORM이 큰 개념이라면 JPA는 더 구체화된 스펙을 포함합니다.</p>
      <p>
        JPA의 매커니즘을 보면 내부적으로 JDBC를 사용합니다. 개발자가 직접 JDBC를 구현하면 SQL에 의존하게 되는 문제 등이
        있어 개발의 효율성이 떨어지는데, JPA는 이 같은 문제점을 보완해서 개발자 대신 적절한 SQL문을 생성하고
        데이터베이스를 조작해서 객체를 자동 매핑하는 역할을 수행합니다.
      </p>
    </InfoBox>
    <h2 id="hibernate"><a href="#hibernate">Hibernate</a></h2>
    <p>Hibernate는 자바의 ORM 프레임워크로, JPA의 구현체 중 하나입니다.</p>
    <h3 id="spring-data-jpa"><a href="#spring-data-jpa">Spring Data JPA</a></h3>
    <p>Spring Data JPA는 스프링에서 JPA를 쉽게 사용할 수 있도록 도와주는 프레임워크입니다.</p>
    <blockquote>
      <p>
        Spring Data JPA는 JPA를 사용하기 위한 인터페이스를 제공하고, Hibernate의 EntityManager를 직접 사용하지 않고
        Repository를 정의해 사용함으로써 개발자가 JPA를 쉽게 사용할 수 있도록 도와줍니다.
        <ImgZoom src="/book-springboot3/page/b.png" alt="/book-springboot3/page/b.png"></ImgZoom>
      </p>
    </blockquote>
    <h2 id=""><a href="#">영속성 컨텍스트</a></h2>
    <p>
      영속성 컨텍스트(Persistence Context)는 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의
      데이터베이스라고 생각하면 됩니다.
    </p>
    <p>엔티티 객체가 영속성 컨텍스트에 들어오면 JPA는 엔티티 객체의 매핑 정보를 데이터베이스에 반영합니다.</p>
    <p>
      이처럼 엔티티 객체가 영속성 컨텍스트에 들어와 JPA의 관리 대상이 되는 시점부터 해당 객체를 <code
        class="inline-code-block">
        영속 객체&lpar;Persistent Object&rpar;
      </code>
      라고 합니다.
    </p>
    <h3 id="entitymanager"><a href="#entitymanager">EntityManager</a></h3>
    <p>EntityManager는 이름 그대로 엔티티를 관리하는 객체입니다.</p>
    <blockquote>
      <p>
        EntityManager는 데이터베이스에 접근해서 CRUD 작업을 수행하는데, Spring Data JPA를 사용하면 Repository를 통해
        데이터베이스에 접근합니다.
      </p>
    </blockquote>
    <h3 id=""><a href="#">엔티티의 생명주기</a></h3>
    <p>엔티티의 생명주기는 크게 비영속, 영속, 준영속, 삭제의 4가지 상태로 나뉩니다.</p>
    <ul>
      <li>비영속(New) : 영속성 컨텍스트에 추가되지 않은 엔티티 객체의 상태를 의미합니다.</li>
      <li>영속(Managed) : 영속성 컨텍스트에 의해 엔티티 객체가 관리되는 상태를 의미합니다.</li>
      <li>준영속(Detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태를 의미합니다.</li>
      <li>
        삭제(Removed) : 데이터베이스에서 레코드를 삭제하기 위해 영속성 컨텍스트에 삭제 요청을 보낸 상태를 의미합니다.
      </li>
    </ul>
    <h2 id=""><a href="#">데이터베이스 연동</a></h2>
    <div class="code-block titled">
      <h2 class="code-title">build.gradle</h2>
      <CodeCopy>
        <pre><code
            class="language-groovy">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  dependencies <span class="token punctuation">{</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">      implementation <span class="token string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">  <span class="token punctuation">}</span></div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <p>Spring Data JPA 의존성을 추가한 후, 별도의 설정이 필요합니다.</p>
    <div class="code-block titled">
      <h2 class="code-title">application.properties</h2>
      <CodeCopy>
        <pre><code
            class="language-properties">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token key attr-name">///</span> <span class="token value attr-value">showLineNumber </span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token comment"># 연동하려는 데이터베이스의 드라이버</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token key attr-name">spring.datasource.driverClassName</span><span class="token punctuation">=</span><span class="token value attr-value">com.mariadb.cj.jdbc.Driver</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token comment"># 연동하려는 데이터베이스의 URL</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token key attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token value attr-value">jdbc:mariadb://localhost:3306/springboot</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token comment"># 연동하려는 데이터베이스의 계정</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token key attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token value attr-value">root</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token comment"># 연동하려는 데이터베이스의 비밀번호</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token key attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token value attr-value">password</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token comment"># JPA 설정</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token comment"># 애플리케이션 실행 시점에 데이터베이스 테이블을 생성하는 방법</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token key attr-name">spring.jpa.hibernate.ddl-auto</span><span class="token punctuation">=</span><span class="token value attr-value">create</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token comment"># 로그에 하이버네이트가 생성한 SQL문을 출력하는 옵션</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token key attr-name">spring.jpa.show-sql</span><span class="token punctuation">=</span><span class="token value attr-value">true</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token comment"># 로그에 하이버네이트가 생성한 SQL문을 포맷팅하는 옵션</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token key attr-name">spring.jpa.properties.hibernate.format_sql</span><span class="token punctuation">=</span><span class="token value attr-value">true</span></div></div>`}</code></pre>
      </CodeCopy>
    </div>
    <details>
      <summary>ddl-auto 옵션</summary>

      <div markdown="1">
        <ul>
          <li>
            <code class="inline-code-block">create</code>
             : 애플리케이션 실행 시점에 기존 테이블을 삭제하고 새로 생성합니다.
          </li>
          <li>
            <code class="inline-code-block">create-drop</code>
             : create와 동일한 기능을 수행하나, 애플리케이션 종료 시점에 테이블을 삭제합니다.
          </li>
          <li>
            <code class="inline-code-block">update</code>
             : 애플리케이션 실행 시점에 객체를 검사하여 변경된 스키마를 갱신합니다. 기존에 저장된 데이터는 유지됩니다.
          </li>
          <li>
            <code class="inline-code-block">validate</code>
             : update처럼 객체를 검사하지만 변경된 스키마를 갱신하지 않습니다. 검사 과정에서 테이블과 엔티티의 스키마가 일치하지
            않으면 에러가 발생합니다.
          </li>
          <li>
            <code class="inline-code-block">none</code>
             : ddl-auto 기능을 사용하지 않습니다.
          </li>
        </ul>
      </div>
    </details>
  </article>
</Post>
