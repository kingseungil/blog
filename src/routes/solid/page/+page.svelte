<!-- auto-generated by QWER -->
<script lang="ts">
  /* eslint-disable @typescript-eslint/ban-ts-comment */
  // @ts-nocheck
  import Post from '$lib/layouts/post.svelte';
  import ImgZoom from '$lib/components/image_zoom.svelte';
  import Video from '$lib/components/video.svelte';
  import CodeCopy from '$lib/components/code_copy.svelte';
  import InfoBox from '$lib/components/info_box.svelte';
</script>

<Post>
  <article slot="post_content">
    <h2 id="solid"><a href="#solid">객체지향 설계 원칙 (SOLID)</a></h2>
    <blockquote>
      <p>객체지향 설계 원칙(SOLID)은 객체지향 프로그래밍(OOP)에서 지켜야 할 5가지 원칙을 말한다.</p>
    </blockquote>
    <h3 id="srp-single-responsibility-principle">
      <a href="#srp-single-responsibility-principle">SRP (Single Responsibility Principle)</a>
    </h3>
    <blockquote>
      <p>
        <code class="inline-code-block">SRP &lpar;Single Responsibility Principle&rpar;</code>
         : 단일 책임 원칙
      </p>
      <ul>
        <li>
          한 클래스는 하나의 책임만 가져야 한다.
          <ul>
            <li>
              하나의 책임이라는 것은 모호하다.
              <ul>
                <li>클 수 있고, 작을 수 있다.</li>
                <li>문맥과 상황에 따라 다르다.</li>
              </ul>
            </li>
            <li>중요한 기준은 변경이다. 변경이 있을 때, 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.</li>
          </ul>
        </li>
        <li>
          SRP를 잘 지키면 결국, <strong>응집도는 높고, 결합도는 낮아진다.</strong>
        </li>
      </ul>
    </blockquote>
    <h3 id="ocp-open-closed-principle"><a href="#ocp-open-closed-principle">OCP (Open Closed Principle)</a></h3>
    <blockquote>
      <p>
        <code class="inline-code-block">OCP &lpar;Open Closed Principle&rpar;</code>
         : 개방 폐쇄 원칙
      </p>
      <ul>
        <li>
          확장에는 열려있고, 변경에는 닫혀있어야 한다.
          <ul>
            <li>
              <strong>확장에 열려있다</strong>
               : 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 확장할 수 있다.
            </li>
            <li>
              <strong>변경에 닫혀있다</strong>
               : 변경 사항이 발생했을 때 객체를 직접적으로 수정하는 것을 제한한다.
            </li>
          </ul>
        </li>
        <li>어렵게 생각할 필요없이, 추상화 사용을 통해 관계 구축을 유연하게 한다.</li>
        <li>
          즉, <strong>다형성</strong>
          과
          <strong>확장</strong>
          을 가능케 하는 객체지향의 장점을 살린 설계 원칙이다.
        </li>
      </ul>
      <p>하지만, 문제점이 있다. 아래 코드를 보자.</p>
      <div class="code-block">
        <CodeCopy>
          <pre><code
              class="language-java">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">   <span class="token comment">// private MemberRepository memberRepository = new MemoryMemberRepository();</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">   <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdbcMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token punctuation">}</span></div></div>`}</code></pre>
        </CodeCopy>
      </div>
      <p>위 코드는 OCP를 잘 지키지 못하고 있다.</p>
      <p>이유는 MemberService는 MemberRepository에 의존하고 있기 때문이다.</p>
      <p>MemberRepository가 변경되면 MemberService도 변경되어야 한다. 즉, 변경에 닫혀있지 않다고 볼 수있다.</p>
      <p>이를 해결하기 위해선, 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.</p>
      <p>
        이는 <code class="inline-code-block">DI</code>
        ,
        <code class="inline-code-block">IoC</code>
        를 통해 해결할 수 있다.
      </p>
    </blockquote>
    <h3 id="lsp-liskov-substitution-principle">
      <a href="#lsp-liskov-substitution-principle">LSP (Liskov Substitution Principle)</a>
    </h3>
    <blockquote>
      <p>
        <code class="inline-code-block">LSP &lpar;Liskov Substitution Principle&rpar;</code>
         : 리스코프 치환 원칙
      </p>
      <ul>
        <li>자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다.</li>
        <li>상속보다는 Interface를 고려하고, 상속을 하더라도 비슷하게 만들어야 교체가 쉽다.</li>
      </ul>
    </blockquote>
    <h3 id="isp-interface-segregation-principle">
      <a href="#isp-interface-segregation-principle">ISP (Interface Segregation Principle)</a>
    </h3>
    <blockquote>
      <p>
        <code class="inline-code-block">ISP &lpar;Interface Segregation Principle&rpar;</code>
         : 인터페이스 분리 원칙
      </p>
      <ul>
        <li>
          Interface도 OCP를 따라야 구현이 편리하고 재활용성이 높아진다.
          <ul>
            <li>특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.</li>
            <li>인터페이스가 명확해지고, 대체 가능성이 높아진다.</li>
          </ul>
        </li>
      </ul>
    </blockquote>
    <h3 id="dip-dependency-inversion-principle">
      <a href="#dip-dependency-inversion-principle">DIP (Dependency Inversion Principle)</a>
    </h3>
    <blockquote>
      <p>
        <code class="inline-code-block">DIP &lpar;Dependency Inversion Principle&rpar;</code>
         : 의존 역전 원칙
      </p>
      <ul>
        <li>
          의존 관계를 맺을 때, 변화하기 쉬운 것보다 변화하기 어려운 것에 의존해야 한다.
          <ul>
            <li>프로그래머는 &quot;추상화에 의존해야지, 구체화에 의존하면 안된다.&quot;</li>
          </ul>
        </li>
        <li>쉽게 말해, 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 것이다.</li>
      </ul>
      <div class="code-block">
        <CodeCopy>
          <pre><code
              class="language-java">{@html String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MemberService</span> <span class="token punctuation">{</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">   <span class="token comment">// private MemberRepository memberRepository = new MemoryMemberRepository();</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">   <span class="token keyword">private</span> <span class="token class-name">MemberRepository</span> memberRepository <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdbcMemberRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"><span class="token punctuation">}</span></div></div>`}</code></pre>
        </CodeCopy>
      </div>
      <p>아까 봤던 이 코드는, 인터페이스에 의존하지만 동시에 구현 클래스에도 의존하고 있다.</p>
      <p>따라서 DIP도 잘 지키지 못하고 있다.</p>
    </blockquote>
    <h2 id=""><a href="#">정리</a></h2>
    <ul>
      <li>
        객체지향의 핵심은 <code class="inline-code-block">다형성</code>
      </li>
      <li>다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.</li>
      <li>다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.</li>
      <li>다형성만으로는 OCP,DIP를 지킬 수 없다.</li>
      <li>
        뭔가 더 필요하다 -&gt; <code class="inline-code-block">스프링 IoC 컨테이너</code>
         : 스프링 컨테이너는 객체를 생성하고, 관리하면서 의존관계를 연결해준다.
      </li>
    </ul>
  </article>
</Post>
