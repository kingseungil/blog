---
title: Clean Code (동시성)
description: 클린코드(13장)을 읽고 정리한 글입니다.
summary: Part 13. 동시성
published: '2024-03-22T15:40:00.000+08:00'
updated: '2023-03-22T15:40:00.000+08:00'
tags:
  - [클린코드, clean code]
series_title: (북스터디) 클린 코드
series_tag: '클린 코드'
cover: https://image.yes24.com/goods/11681152/XL
---

# Part 13. 동시성

## 동시성 프로그래밍이란

:::info 동시성 프로그래밍
어플리케이션을 효율적으로 실행하기 위해 멀티코어를 온전히 활용하도록 구현하는 방식
:::

> 외부 서비스의 응답을 기다리면서 아무일도 하지 않으면 CPU 사이클이 낭비된다!
> 
> `낭비되는 자원을 줄이자`

![](images/d87a471a.png)

## 동시성 프로그래밍이 필요한 이유

### 동시성 프로그래밍의 미신과 오해

- 동시성은 항상 성능을 높여준다? `NO!`
- 동시성은 **때때로** 성능을 높여준다? `YES!`

> 동시성은 대기 시간이 아주 길어 여러 스레드가 프로세스를 공유할 수 있거나, 여러 프로세스가 동시에 처리할 독립적인 계산이
> 충분히 많은 경우에만 성능이 높아진다.
> 
> 예시: 웹 브라우저에서 여러 가지 이미지 리소스들을 불러와서 다운로드 받는 경우
> 
> - 이미지를 다운로드 받는 동안 다른 이미지를 다운로드 받는 스레드가 다른 이미지를 다운로드 받는다.
> - 이렇게 하면 이미지를 다운로드 받는 시간이 줄어들고, 사용자는 더 빠르게 이미지를 볼 수 있다.

- 동시성을 구현해도 설계는 변하지 않는다? `NO!`
- 동시성을 구현하면 설계를 바꿔야 한다? `YES!`

> 단일 스레드 시스템과 다중 스레드 시스템은 설계가 많이 달라진다.
> 
> `무엇`과 `언제`를 분리하면 시스템의 구조가 크게 달라진다.

- Web이나 EJB같은 컨테이너를 사용한다면 동시성을 이해할 필요가 없다? `NO!`
- 컨테이너를 사용해도 동시성을 이해해야 한다? `YES!`

> 어플리케이션이 컨테이너를 통해 멀티 쓰레드를 사용하는 것이기 때문에 컨테이너의 동작을 이해해야 한다.
> 
> `동시 수정`, `데드락` 같은 문제를 피할 수 있는지를 알아야 한다.

## 안전한 동시성 프로그래밍 규칙

### 단일 책임 원칙(SRP) 설계

> 동시성 관련 코드는 다른 코드와 분리하라

- 동시성 코드는 독자적인 개발,변경,조율 주기가 있다.
- 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
- 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.

### 자료 범위를 제한하라

> 공유 자료를 최대한 줄여라

- 동시 수정 문제를 피하기 위해 객체를 사용하는 코드 내 임계영역을 `synchronized` 키워드로 보호한다.
- 보호할 임계영역을 빼먹거나, 모든 임계영역을 보호했는지 확인하느라 수고가 드므로 **임계 영역의 수를 최소화 해야 한다.**

### 자료 사본을 사용하라

> 공유 자료를 줄이려면, 최대한 공유하지 않는 방법이 제일 좋다

- 객체를 복사해 읽기 전용을 사용한다.
- 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져온다
- 사본을 사용하는 방식으로 내부 잠금을 없애 수행 시간을 절약하는 것이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.

### Thread는 가능한 독립적으로 구현하라

> 다른 스레드와 자료를 공유하지 않는다

- 서블릿처럼 각 Thread는 클라이언트 요청 하나를 처리한다.
- 모든 정보는 비공유 출처(client의 request)에서 가져오며 로컬 변수에 저장한다.
- 각 서블릿은 마치 자신이 독자적인 시스템에서 동작하는 것처럼 동작한다.

### 라이브러리를 이해하라

> java.util.concurrent 패키지를 익혀라

- Thread Safe한 컬렉션을 사용한다 (ConcurrentHashMap, AtomicLong ...)
- 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다.
- 가능하다면 Thread가 Blocking되지 않는 방법을 사용한다.